# Dubbo CVE-2021-30179

这一篇想详细的分析一下流程嘿嘿
学习:https://mp.weixin.qq.com/s?__biz=MzA4NzUwMzc3NQ==&mid=2247488856&idx=1&sn=ee37514a5bfbf8c35f4ec661a4c7d45a&chksm=903933a8a74ebabecaf9428995491494f20e5b24a15f8d52e79d3a9dac601620c21d097cdc1f&scene=21#wechat_redirect (环境搭建)

https://mp.weixin.qq.com/s/vHJpE2fZ8Lne-xFggoQiAg (漏洞分析)

## 影响版本

Apache Dubbo 2.7.0 to 2.7.9

Apache Dubbo 2.6.0 to 2.6.9

Apache Dubbo all 2.5.x versions (官方已不再提供支持)

## 流程分析

因为具体不清楚dubbo的机制，就直接从DecodeHandler#received方法开始分析。I
![image-20230103161500439](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031615558.png)

获取到Data字段为DecodeableRpcInvocation对象，在DecodeHandler#decode中进入if判断，并且进入DecodeableRpcInvocation#decode
![image-20230103170128995](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031701132.png)

![image-20230103182333503](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031823580.png)

由于在demo中DemoService没有$invoke方法，即进入下面if语句。

然后到了熟悉的判断是否符合调用了相关的方法。$invoke等。最后将获取的对象进行反序列化。
![image-20230103183342183](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031833267.png)

读取出map的值，我们写入的map值，将其与前面从流中读取的值放到同一个map中。
![image-20230103183607675](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031836747.png)

最后跳出获取的data字段的解码，进入HeaderExchangeHandler#received中，最后会进入DubboProtocol#received中。继续跟进（因为感觉这里的代码不重要，就继续走了），继续跟进会来到ProtocolFilterWrapper#invoke中，进入EchoFilter#invoke中，自然是获取不到$echo方法。继续进入invoke![image-20230103190313402](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031903448.png)

最后来到Classloaderfilter#invoke然后又进入ProtocolFilterWrapper#invoke中，来到GenericFilter#invoke中。

这里也来到了关键性的一步：
![image-20230103192523059](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031925106.png)

最后进行触发
![image-20230103192658176](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031926281.png)

## 思考1

其实就是看着POC来思考：

固定魔数值（0xdabb），我们可以通过这两个Byte，判断是否为Dubbo协议：`Bytes.short2bytes((short) 0xdabb, header);`

为获取到`hessianSerialization`：`header[2] = (byte) ((byte) 0x80 | 2);`

设置为request：`Bytes.long2bytes(new Random().nextInt(100000000), header, 4);`

然后写入对应之前readUTF相应的值。

创建socket进行连接。
然后我看到getBeanPayload中对应写的type为7？嗯？回头看看？

![image-20230103195853960](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301031958058.png)

为什么只有7可以呢？因为其中result = instantiate(componentType);会将其实例化。看看其他几个均被pass。

![image-20230103200059920](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301032001072.png)

然后就是设置asText：是因为如下图会获取seetter方法进入有相关代码得到。
![image-20230103200432458](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301032004571.png)

最后触发。

## 思考2

在GenericFilter中有许多的`ProtocolUtils.isProtobufGenericSerialization`进行判断？为什么只有map.put("generic", "bean");可行呢？
于是我观察其他几个地方发现同样可行。额....结果发现poc已经写了出来。