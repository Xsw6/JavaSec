# CVE-2016-0638

上一个CVE的修复方式影响的具体内容（懒...不想去手操）

https://xz.aliyun.com/t/10173#toc-1

https://xz.aliyun.com/t/8443#toc-0

（这几篇文章说的很清楚）

其实这个补丁打的根本原因就是我们最后漏洞用的是ServerChannelInputStream.readObject,而它就是再反序列化的必经之路上resolveClass添加了黑名单，如果存在就抛出异常【`再Class.forname(ServerChannelInputStream)之前`】，所以无法反序列化成功。

绕过思路就是找一个不利用ServerChannelInputStream对象进行反序列化的即可。
于是找到了`StreamMessageImpl#readExternal()`

只不过需要满足一些条件【`直接重写类就行了`】：
![image-20230117111144905](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301171111107.png)

第一个需要满足的点：var1=3

第二个需要满足的点（跟进(PayloadStream)PayloadFactoryImpl.createPayload）：
通过流程分析，我们可以知道：
![image-20230117113301029](https://cdn.jsdelivr.net/gh/zx-creat/myblog@master/img/202301171133182.png)

最后同chunk进行包装.后续进行反序列化。
